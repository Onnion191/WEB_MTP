<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WindowAddon Documentation: Event System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="inline_params.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WindowAddon Documentation
   &#160;<span id="projectnumber">Stable 1.1</span>
   </div>
   <div id="projectbrief">WindowAddon is a simple light-weight C++ library based on Allegro to get started in computer graphics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('events.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Event System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>If you have checked the previous tutorials on how to use the <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a>, maybe you are asking yourself: "Well, primitives and direct orders are the only way to use the Window? How can I get information about user's interaction on the screen?". <br />
<br />
 A <a class="el" href="union_window_event.html" title="Data structure that contains all the information about a Window event. ">WindowEvent</a> is produced when the <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a> outputs some information that can be received by the main program and then processed. An example of this concept is a mouse click. The <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a> will report the pixel coordinates where the mouse was pointing at when the button was pressed (or released). But this is not the only type of event the window can report. The event system of the <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a> is based in <a href="https://www.allegro.cc/manual/5/events.html">Allegro Event System</a> and works almost the same way, so checking what an <a href="https://www.allegro.cc/manual/5/ALLEGRO_EVENT">Allegro Event</a> is will benefit you.</p>
<h1><a class="anchor" id="window_event"></a>
Window Event</h1>
<p>What is exactly a <a class="el" href="union_window_event.html" title="Data structure that contains all the information about a Window event. ">WindowEvent</a>? It uses the concept of <a href="http://www.cplusplus.com/doc/tutorial/other_data_types/">union</a> to use one structure as a container for all the possible types of event. It's like a container large enough to store the information of all types of events the <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a> can throw. Some events have fields that others don't, but all events have three fields in common: </p><ul>
<li>
<b>type</b> : type of event. You'll need this field in order to classify them. </li>
<li>
<b>any.source</b> : the source that generated that particular event. </li>
<li>
<b>any.timestamp</b> : time when that particular event was produced. </li>
</ul>
<p>As you can see, all events have a field called <em>any</em> that contains the fields in common with other events (except for the type). Other fields are tpye-specific and you should analyze the type of the event before accessing them. All the fields of the <a class="el" href="union_window_event.html" title="Data structure that contains all the information about a Window event. ">WindowEvent</a> have the same meaning as the ones in an <a href="https://www.allegro.cc/manual/5/ALLEGRO_EVENT">Allegro Event</a>, so feel free to check its documentation for more information. You can also visit <a class="el" href="group__event__handling.html">Event Handling</a> to check what functions does the <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a> have to manage its events. <br />
<br />
 <b>NOTE</b>: If you have any doubts of what types of event you can receive from the <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a> and what they mean, you should also check <a class="el" href="_event_8h_source.html">Event.h</a> file. It is pretty self-explanatory, so if you have a some C/C++ experience you will find it easy to read and maybe it helps you to understand how the events work. You should check <a href="https://www.allegro.cc/manual/5/ALLEGRO_EVENT">Allegro Event</a> before doing this, it's a better guide to understand how they work and you'll probably find what you're looking for there. <br />
<br />
 You will find some examples of <a class="el" href="union_window_event.html" title="Data structure that contains all the information about a Window event. ">WindowEvent</a> handling below.</p>
<h1><a class="anchor" id="generic_event_handling"></a>
General Event Handling</h1>
<p>For simple programs that don't require a lot of event handling, you can use the built-in functions that allow you to capture the basic information of some events, but if you want more flexibility you will need something more. This is why the <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a> also has the complete, unfiltered version of event handling methods. With them, you will be able to get all the information about all events produced by the event sources attached to the screen, such as the keyboard or the mouse, for example.</p>
<p>These methods are <a class="el" href="group__event__handling.html#gab1afa5578a8002bd269c4ce8a6119e54">Window::waitWindowEvent()</a> and <a class="el" href="group__event__handling.html#gabb017ba5f34d7bff34ae838731861ad9">Window::waitWindowEventTimed()</a>, which return a <a class="el" href="union_window_event.html" title="Data structure that contains all the information about a Window event. ">WindowEvent</a> structure. They are overloaded, allowing to pass a parameter of type <em>WindowEventType</em> to specify what type of event you're waiting for, discarding the rest. This parameter is called <em>ev_type</em> and it's useful when you are interested in receiving only one type of event.</p>
<p>The main difference between <a class="el" href="group__event__handling.html#gab1afa5578a8002bd269c4ce8a6119e54">Window::waitWindowEvent()</a> and its brother <a class="el" href="group__event__handling.html#gabb017ba5f34d7bff34ae838731861ad9">Window::waitWindowEventTimed()</a> is that the second one can receive a timeout in seconds as a parameter (called <em>seconds</em>), allowing the programmer to make a responsive program that does not get stuck waiting for events.</p>
<p>Let's see some examples: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;WindowAddon.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="class_window.html">Window</a> w(300, 300);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> end = <span class="keyword">false</span>;</div><div class="line">    <a class="code" href="union_window_event.html">WindowEvent</a> event;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(!end){</div><div class="line">        <span class="keyword">event</span>  = w.<a class="code" href="group__event__handling.html#gab1afa5578a8002bd269c4ce8a6119e54">waitWindowEvent</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(event.<a class="code" href="union_window_event.html#a1c7d9c28d9678364ada2109b0ae512ed">type</a> == WINDOW_EVENT_DISPLAY_CLOSE){</div><div class="line">            end = <span class="keyword">true</span>; <span class="comment">//finish the program</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(event.<a class="code" href="union_window_event.html#a1c7d9c28d9678364ada2109b0ae512ed">type</a> == WINDOW_EVENT_MOUSE_BUTTON_DOWN){</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Mouse button was pressed&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(event.<a class="code" href="union_window_event.html#a1c7d9c28d9678364ada2109b0ae512ed">type</a> == WINDOW_EVENT_KEY_DOWN){</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Keyboard key was pressed&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span>{</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Another type of event&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> In this example you can see a pretty simple event handling. If the <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a> close button is pressed, the program will finish. If a mouse button or a key is pressed, it will print out a message telling that, and the other events will produce a generic message. If you run this code you will observe that a lot of unknown events are captured when the cursor passes over the screen. You should check what type of event does the <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a> receive to understand why this is happening.</p>
<p>The previous example has one flaw: if no event is received, the program will hang forever. This is why you should use <a class="el" href="group__event__handling.html#gabb017ba5f34d7bff34ae838731861ad9">Window::waitWindowEventTimed()</a> instead. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;WindowAddon.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="class_window.html">Window</a> w(300, 300);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> end = <span class="keyword">false</span>;</div><div class="line">    <a class="code" href="union_window_event.html">WindowEvent</a> event;</div><div class="line">    <span class="keywordtype">float</span> timeout = 0.06;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(!end){</div><div class="line">        <span class="keyword">event</span>  = w.<a class="code" href="group__event__handling.html#gabb017ba5f34d7bff34ae838731861ad9">waitWindowEventTimed</a>(timeout);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(event.<a class="code" href="union_window_event.html#a1c7d9c28d9678364ada2109b0ae512ed">type</a> == WINDOW_EVENT_DISPLAY_CLOSE){</div><div class="line">            end = <span class="keyword">true</span>; <span class="comment">//finish the program</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(event.<a class="code" href="union_window_event.html#a1c7d9c28d9678364ada2109b0ae512ed">type</a> == WINDOW_EVENT_MOUSE_BUTTON_DOWN){</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Mouse button was pressed&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(event.<a class="code" href="union_window_event.html#a1c7d9c28d9678364ada2109b0ae512ed">type</a> == WINDOW_EVENT_KEY_DOWN){</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Keyboard key was pressed&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span>{</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Another type of event&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Doing it this way you will not have any problem. But be careful, because when the timeout expires, a timeout event is generated and returned by the function (<em>WINDOW_EVENT_TIMER</em> event type). In the previous example, that event would be treated in the <em>else</em> case, and maybe you don't want that. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;WindowAddon.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="class_window.html">Window</a> w(300, 300);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> end = <span class="keyword">false</span>;</div><div class="line">    <a class="code" href="union_window_event.html">WindowEvent</a> event;</div><div class="line">    <span class="keywordtype">float</span> timeout = 0.06;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(!end){</div><div class="line">        <span class="keyword">event</span>  = w.<a class="code" href="group__event__handling.html#gabb017ba5f34d7bff34ae838731861ad9">waitWindowEventTimed</a>(timeout);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(event.<a class="code" href="union_window_event.html#a1c7d9c28d9678364ada2109b0ae512ed">type</a> == WINDOW_EVENT_DISPLAY_CLOSE){</div><div class="line">            end = <span class="keyword">true</span>; <span class="comment">//finish the program</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(event.<a class="code" href="union_window_event.html#a1c7d9c28d9678364ada2109b0ae512ed">type</a> == WINDOW_EVENT_MOUSE_BUTTON_DOWN){</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Mouse button was pressed&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(event.<a class="code" href="union_window_event.html#a1c7d9c28d9678364ada2109b0ae512ed">type</a> == WINDOW_EVENT_KEY_DOWN){</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Keyboard key was pressed&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(event.<a class="code" href="union_window_event.html#a1c7d9c28d9678364ada2109b0ae512ed">type</a> == WINDOW_EVENT_TIMER){</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Event timeout expired&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span>{</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Another type of event&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This last example takes that into account.</p>
<h1><a class="anchor" id="concrete_event_handling"></a>
Concrete Event Handling</h1>
<p>The section above has shown how powerful the event concept is, but why should you care about handling other events that you don't want to? <br />
<br />
 Because of that, <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a> has some functions that allow you to abstract from this concept of event and retrieve only some relevant information from them. You can also find these calls in <a class="el" href="group__event__handling.html">Event Handling</a>. <br />
<br />
 One feature that is missing in all these concrete event handlers is the possibility to set a timeout. If you don't want your program to hang forever, you must use general event handlers. Also you have to bear in mind that all other events generated during one of these calls are discarded. They do not persist in the event queue.</p>
<h2><a class="anchor" id="close_button_event_handling"></a>
Close Button Event handling</h2>
<p>If you did not notice it, almost all the examples you will find in this documentation contain a line calling the method <a class="el" href="group__event__handling.html#ga4835984c1a66bbe02065873d9133b5ea">Window::waitWindowCloseButton()</a>. As its name suggests, this method stops the thread that called it until <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a>'s close button is pressed. You will almost always want to call it just at the end of your program to make the <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a> persist, but this is not the only use case. <br />
<br />
 For example if you run the following code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;WindowAddon.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv){</div><div class="line">    <a class="code" href="class_window.html">Window</a> w(300, 300);</div><div class="line"></div><div class="line">    w.<a class="code" href="group__event__handling.html#ga4835984c1a66bbe02065873d9133b5ea">waitWindowCloseButton</a>();</div><div class="line"></div><div class="line">    w.<a class="code" href="group__text__operations.html#gae24fd66834c7d5ee2fa6f5899dc4efba">text</a>(150, 150, <span class="stringliteral">&quot;Hey there!&quot;</span>, <a class="code" href="group__text__align.html#ga311b71a030d8c4df8d82ca8ef82e97b9">TEXT_ALIGN_CENTER</a>);</div><div class="line"></div><div class="line">    w.<a class="code" href="group__event__handling.html#ga4835984c1a66bbe02065873d9133b5ea">waitWindowCloseButton</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> You'll not see the text printed on the screen until the button is pressed. Then, if you press it again, the main function will return and the program will finish. This could be useful if you want to prompt a warning before closing the <a class="el" href="class_window.html" title="Mid-level interface class that allows you to access all the functionalities of the library...">Window</a>, for example. <br />
<br />
 As simple as it is, you'll probably want to use this line in all your projects since it comes very handy when you want to print something to the screen and make it rest there until the user wants to close the program.</p>
<h2><a class="anchor" id="mouse_event_handling"></a>
Mouse Event Handling</h2>
<p>It's a common thing to want something as simple as knowing where the user clicks with the mouse. Why should you build an event handling structure if you only want to know the coordinates of that point? It's your lucky day, because you don't have to. With mouse event handling methods like <a class="el" href="group__event__handling.html#ga9ba396ae28f7ae615df181279337a872">Window::waitMouseClick()</a> you'll not have to worry about anything (except for the fact that your program will stop waiting for the mouse click). Once the user clicks on the screen and the function returns, you'll get the coordinates where the cursor was pointing at. Easy right? <br />
</p>
<p>Let's start with the <b>basic</b>: what can you expect from a mouse's behavior? You could expect the buttons to be pressed or released. All mouse event handling functions have a parameter in common: <em>onRelease</em>. It is a boolean parameter that tells the method to wait for a pressing button event when <em>onRelease</em> = <em>false</em>, or for a releasing button event when <em>onRelease</em> = <em>true</em>. By default this parameter is <em>false</em> so the method will wait for pressing events. <br />
</p>
<p>For example this code will wait for a pressing left click with <a class="el" href="group__event__handling.html#ga775af4bc74ba0ff0bb251b9db3a7a9f9">Window::waitMouseLeftClick()</a> before showing the text: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;WindowAddon.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv){</div><div class="line">    <a class="code" href="class_window.html">Window</a> w(300, 300);</div><div class="line"></div><div class="line">    w.<a class="code" href="group__event__handling.html#ga775af4bc74ba0ff0bb251b9db3a7a9f9">waitMouseLeftClick</a>();</div><div class="line"></div><div class="line">    w.<a class="code" href="group__text__operations.html#gae24fd66834c7d5ee2fa6f5899dc4efba">text</a>(150, 150, <span class="stringliteral">&quot;Hey there!&quot;</span>, <a class="code" href="group__text__align.html#ga311b71a030d8c4df8d82ca8ef82e97b9">TEXT_ALIGN_CENTER</a>);</div><div class="line"></div><div class="line">    w.<a class="code" href="group__event__handling.html#ga4835984c1a66bbe02065873d9133b5ea">waitWindowCloseButton</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <br />
 You could do the same but using <a class="el" href="group__event__handling.html#gaf34ed65322436be50a0bfb67b70d55ec">Window::waitMouseRightClick()</a> instead. The program would wait for a pressing right click event. If you don't want to wait for a specific button but for any button instead, you can use <a class="el" href="group__event__handling.html#ga9bf4229676738249b382d3efa6512e07">Window::waitMouseAnyClick()</a>. In this example the return value of the <a class="el" href="group__event__handling.html#ga775af4bc74ba0ff0bb251b9db3a7a9f9">Window::waitMouseLeftClick()</a> was not used, but you would get the point where the cursor was when the user clicked. <br />
</p>
<p>And what if you want to be able to use more buttons than the typical left and right ones? Then you can use <a class="el" href="group__event__handling.html#ga9ba396ae28f7ae615df181279337a872">Window::waitMouseClick()</a> that has an integer parameter <em>mouse_button</em> referencing to the <em>id</em> of the button you want to listen. Generally, <em>id 0</em> refers to the left button and <em>id 1</em> to the right one, but you cannot ensure what <em>id</em> will have the programmable buttons in some mice. And some mice maybe don't have that buttons, be careful.</p>
<p>For example, <em>Window::waitMouseClick(1)</em> would be equivalent to <a class="el" href="group__event__handling.html#gaf34ed65322436be50a0bfb67b70d55ec">Window::waitMouseRightClick()</a>.</p>
<p>One limitation of this approach is that you cannot wait for two different buttons at once (if that even makes sense). You will have to build a custom event handler to do that.</p>
<h2><a class="anchor" id="keyboard_event_handling"></a>
Keyboard Event Handling</h2>
<p>You can also get information about what keys are being pressed or released. Having a function for every key is a bad idea, so here you only have two options: <a class="el" href="group__event__handling.html#gac5308d79d67322c3161515165b14e130">Window::waitAnyKeypress()</a> to wait until any key is pressed or <a class="el" href="group__event__handling.html#ga4396569a898fee209b36065bf9162f45">Window::waitKeypress()</a> that receives a <em>key id</em> as a parameter, and waits until that key is pressed. You can check key ids on <a class="el" href="_event_8h_source.html">Event.h</a>. Both methods return the <em>id</em> of the pressed key. As mouse events, you can specify with the boolean parameter <em>onRelease</em> if you want to wait for the key to be pressed or to be released.</p>
<p>For example, this code will wait until the <em>Space Bar</em> is released, then the text will be shown. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;WindowAddon.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv){</div><div class="line">    <a class="code" href="class_window.html">Window</a> w(300, 300);</div><div class="line"></div><div class="line">    w.<a class="code" href="group__event__handling.html#ga4396569a898fee209b36065bf9162f45">waitKeypress</a>(KEYBOARD_KEY_SPACE, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    w.<a class="code" href="group__text__operations.html#gae24fd66834c7d5ee2fa6f5899dc4efba">text</a>(150, 150, <span class="stringliteral">&quot;Hey there!&quot;</span>, <a class="code" href="group__text__align.html#ga311b71a030d8c4df8d82ca8ef82e97b9">TEXT_ALIGN_CENTER</a>);</div><div class="line"></div><div class="line">    w.<a class="code" href="group__event__handling.html#ga4835984c1a66bbe02065873d9133b5ea">waitWindowCloseButton</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
