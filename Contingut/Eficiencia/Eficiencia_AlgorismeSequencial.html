<!DOCTYPE html>

<html lang="ca">

<head>


    <link rel="stylesheet"  href="../../styles/Style.css" type="text/css" media="screen">
    <link rel="stylesheet" href="../../styles/vs.min.css">
    <meta charset="utf-8">


    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script src="../../CustomScripts.js"></script> 
    <!-- Pels blocks de codi -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>


    <!-- scale font size for MathJax -->
    <title>UDG AJUTS DE PROGRAMACIÓ</title>

</head>

<body onload="checkMenuById('#collapse-input-1');">

<div id = "menu"></div>

<div id = "content">
  <center>
    <h1 class = "center">
      1.4 ALGORISMES SEQÜENCIALS
    </h1>
  </center>
    <h4>Estudi de la complexitat en un algorisme seqüencial</h4>
    <teoria>
        Com hem vist anteriorment disposem de diferents <a href="Eficiencia_OrdreComplexitat.html">ordres de complexitat</a> els quals ens donen una idea del cost d'un algorisme. Agafarem aquesta idea per tal de poder saber quin és el nostre grau d'eficiència en un algorisme seqüencial.
    </teoria>
    <h3>Cost de les instruccions</h3>
    <teoria>
        Un algorisme seqüencial consta d'un seguit d'instruccions conseqÑutives, per tant si tenim un programa com aquest: <br>
        
        <pseudocodi><pre><code class="nohighligh">instrucció 1 (Cost S1)
instrucció 2 (Cost S2)
instrucció 3 (Cost S3)
...
instrucció n (Cost n)</code></pre></pseudocodi>
        Per determinar quin és el cost del nostre algorisme aplicariem la següent expressió. &sum;(S<sub>i</sub>), sumant tots els costos tindriem el cost total. <br>
        Ara bé, en el pitjor dels casos, tindrem un nombre de dades tendint a infinit, i per tant hi ha molts <b>costos que són despreciables</b> en contra d'altres que són realments importants. Per exemple, si tenim un cost constant enfront a un cost quadràtic (n <sup>2</sup>), aleshores el constant és menyspreable. <br> <br>
        
        Així doncs, <b>per calcular el cost</b> simplement ens quedarem amb l'<b>ordre de magnitud més gran</b> de les instruccions que tenim. Per tant el cost és: <b>Max(S1 .... Sn)</b>.
    </teoria>
    
    
    
<!------------------------------------------------------------------------------------------------------------------------------------------------------------->
<!------------------------------------------------------------ EXERCICIS -------------------------------------------------------------------------------------->
<!------------------------------------------------------------------------------------------------------------------------------------------------------------->
    
    
    <h4>Per practicar</h4>
    A continuació donarem un parell d'exercicis senzills perquè pogueu consolidar el temari: 
    
<!------------------------------------------------------------------------------------------------------------------------------------------------------------->
<!------------------------------------------------------------ EXERCICI 1 ------------------------------------------------------------------------------------->
<!------------------------------------------------------------------------------------------------------------------------------------------------------------->    
    <h3>Exercici 1</h3>
    <exercici>Calcular l'ordre de complexitat del següent algorisme:</exercici>
    <pre><code class="C++">double potencia (double base, unsigned exp){
//Pre: cert
//Post: retorna base elevat a exp
    double potencia=1;                    
    for(unsigned i=1; i&lt;=exp; i++)          
        potencia=potencia*base;          
        
    return potencia;                     
}</code></pre>
    
    <!--------------solucio------------>
 <button onclick="myFunction(Ex1)">Solucio</button>
                
   <solucio id="Ex1"><pre><code class="c++">double potencia (double base, unsigned exp){
//Pre: cert
//Post: retorna base elevat a exp
    double potencia=1;                    O(1)
    for(unsigned i=1; i&lt;=exp; i++)          
        potencia=potencia*base;           O(1) exp vegades --> O(exp)

    return potencia;                      O(1) 
}</code></pre>
    Per tant l'ordre final es O(n);
    </solucio>
<!------------------------------------------------------------------------------------------------------------------------------------------------------------->
<!------------------------------------------------------------ EXERCICI 2 ------------------------------------------------------------------------------------->
<!------------------------------------------------------------------------------------------------------------------------------------------------------------->  
    
    <h3>Exercici 2</h3>
    <exercici>Calcular l'ordre de complexitat del següent algorisme:</exercici>
    <pre><code class="C++">       double potencia2 (double base, unsigned exp){
//Pre: cert
//Post: retorna base elevat a exp
    double potencia=1;                    
    unsigned i=exp;                       
    double b=base;                        

    while(i&gt;1){          
        if(i%2==1) potencia=potencia*b; 
        b=b*b;                            
        i=i/2;
    }

    return potencia;                      
}</code></pre>
    
    <!--------------solucio------------>
 <button onclick="myFunction(Ex2)">Solucio</button>
                
   <solucio id="Ex2"><pre><code class="c++">double potencia2 (double base, unsigned exp){
//Pre: cert
//Post: retorna base elevat a exp
    double potencia=1;                    O(1)
    unsigned i=exp;                       O(1)
    double b=base;                        O(1)

    while(i&gt;1){          
        if(i%2==1) potencia=potencia*b; 
        b=b*b;                            O(1) cada iteració  -> O(nIter)
        i=i/2;
    }

    return potencia;                      O(1) 
}</code></pre>
    Per tant l'ordre final es O(log (n));
    </solucio>
    
    
</div>
<p class = footer>
    <a class="backward round" href="Eficiencia_OrdreComplexitat.html"></a>  <a class="forward round" href="Eficiencia_Exercicis.html"></a>
  <center>
      <p class = footer>
      Copyright &copy; 2000&ndash;<span id="anyActual"></span>
      <a href ="https://www.udg.edu/ca/" class = footer>Universitat de Girona</a>
      Tots els drets reservats.
  </center>



</body>

</html>

 