<!DOCTYPE html>

<html lang="en">

<head>


<link rel="stylesheet"  href="../../styles/Style.css" type="text/css" media="screen"></link>
<link rel="stylesheet" href="../../styles/vs.min.css">
<meta charset="utf-8">


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script src="/CustomScripts.js"></script> 
<!-- Pels blocks de codi -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<!-- scale font size for MathJax -->
<title>METODOLOGIA I TECNOLOGIA DE LA PROGRAMACIÓ</title>

</head>

<body>

<div id = "menu"></div>

<div id = "content">
  <center>
    <h1 class = "center">
      SEQÜÈNCIES I FITXERS
    </h1>
  </center>
    
<!-- Contingut escrit -->
<h4>Què és una seqüència</h4>
<teoria>
    Una seqüència és una successió finita d'elements (normalment) del mateix tipus, poguent ser naturals, enters, reals, caràcters o strings.
	<br>S'accedeix de manera seqüencial als seus elements. No es pot anar endavant ni endarrere ni tampoc anar indiscriminadament on es vulgui. 
	Aixó fa que calgui una marca de fi, per poder saber on acaben. Es poden associar a els canals d'entrada sortida estàndars (pantalla i teclat) o a un fitxer 
	i tenen permisos de lectura o escriptura, mai ambdós.

	<br><br>

    <h2>Exemples de sequencies</h2>
   
   <pre><code class = "c++">	
		// Seqüència d’enters (positius)
		2 34 23 34 76  12 4  6765 132 … 3 -1
   
		//Seqüència de reals (majors que 0)
		2.34 23 34.76  12.34  67.65 12 … 1.2 0

		//Seqüència de caràcters
		avui fa sol#

		//Seqüència de dates 
		2 3 2023 3 12 2017 … 4 6 1999 0

    </code></pre>
    Podem veure que la marca de fi sempre està present, sent -1 en la primera, 0 en la segona, un # en la tercera, i en la última un 0.
</teoria>
   
   <br><br>
   
   
    <h4>Marques de fi</h4>
<teoria>
	
	Es poden donar dos tipus de marques de fi:
	<ul>
		<li>Marca de fi lògica (explícita): Donada per un element distingit del mateix tipus que els de la seqüència, com ara els vists en l'exemple anterior.<br>
		Pot ser usada tant en les sequencies de teclat com les de fitxer.
		<br><br>
		<img class="allargatPetit" src="../../Recursos/Imatges/Sequencies_marquesFiLogiques.PNG" alt="exemple de marques de fi lògiques">
		<br><br>
		</li>
		<li> Marca de fi física (implícita): Donada per la marca de final de fitxer del sistema. Com es pot intuir, doncs, només es pot usar en fitxers.
		<br><br>
		<img class="allargatPetit" src="../../Recursos/Imatges/Sequencies_marquesFiFisiques.PNG" alt="exemple de marques de fi físiques">
		<br><br>
		</li>
		
	</ul>
</teoria>
	
	
<h1>
    PROBLEMES DE SEQÜÈNCIES
</h1>
<teoria>
	Els problemes amb seqüències es resolen utilitzant els dos esquemes bàsics següents:
	<ul>
		<li> Recorregut: cal tractar tots els elements de la seqüència fins a arribar a la marca de fi. </li>
		<li> Cerca: si trobem el que cerquem, parem (no cal arribar a la marca de fi), sinó, arribem al final. </li>
	</ul>
	<alerta> Si el problema no exigeix un recorregut, es considera incorrecte aplicar-li. <br></alerta>
	
	<br><br>
	<h2>Recorregut</h2>
	<br><br>
	Esquema en pseudocodi:
		
	<br><br><pseudocodi>
	<pre><code class = "nohighlight">	
		inicialitzar tractament
		llegir element
		mentre no fi de la seqüència fer
			tractar element actual
			llegir element	
		tractament final
    </code></pre>
	</pseudocodi>
	
	En el recorregut cal veure que en el bucle, processem tots els elements de la seqüència, o sigui, fins a trobar la marca de fi.
	
	<br>L'esquema equivalent en c++ sería així:<br><br>
	<pre><code class = "c++">	
	...
	const tipus EOS=element_marca_fi; 
	...
	int main(){
	   ... 
	   inicialitzar_tractament(...);
	   cin>>element; //llegir el primer
	   //mentre no fi: not element==EOS
	   while(element != EOS) {
		  tractar_element(element,...);
		  cin>>element; //llegir el següent
	   }
	   tractament_final(...);
	   ...
	   return 0;
	}
    </code></pre>
	<br><br>
	<h2>Cerca</h2>
	<br><br>
	
	Esquema en pseudocodi:
		
	<br><br><pseudocodi>
	<pre><code class = "nohighlight">	
		inicialitzar tractament
		llegir element
		mentre no fi de la seqüència i no trobat fer
			tractar element actual
			llegir element	
		tractament final
    </code></pre>
	</pseudocodi>
	
	En la cerca cal veure que en el bucle, processem només els elements necessaris fins que detectem la marca de fi de la seqüència o es troba el que es busca.	
	<br>L'esquema equivalent en c++ sería així:<br><br>
	<pre><code class = "c++">	
	... 
	const tipus EOS=element_marca_fi;
	...
	int main() {
	   ...
	   inicialitzar_tractament(trobat,...); //trobat=false
	   cin>>element; //llegir el primer
	   //mentre no fi: not(element==EOS or trobat)
	   while(element != EOS and not trobat) {
		  tractar_element(element,trobat,...);
		  if(not trobat) 
			 cin>>element; //llegir el següent
	   }
	   tractament_final(trobat,...);
	   ...
	   return 0;
	}

    </code></pre>
	<br><br>
</teoria>    
 <br><br>

 
<h1>
    SEQÜÈNCIES EN C++: STREAMS
</h1>
<teoria>
	El C++ no disposa del concepte abstracte de seqüència, les seqüències s'implementen amb streams que permeten el flux (entrada i sortida) de dades:
	<br><br>
	<img class="mitjana" src="../../Recursos/Imatges/SequenciesFitxers_streams.PNG" alt="imatge explicativa sobre streams">
	<br><br>






</teoria>

  <p class = footer>
  <center>
      <p class = footer>
      <!--<em>Last modified on February 19, 2018.</em><br><br>-->
      Copyright &copy; 2000&ndash;2018
      <a href ="https://www.udg.edu/ca/" class = footer>Universitat de Girona</a>
      Tots els drets reservats.
  </center>
</div>



</body>

</html>

