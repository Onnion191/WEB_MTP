<!DOCTYPE html>

<html lang="en">

<head>


<link rel="stylesheet"  href="../../styles/Style.css" type="text/css" media="screen"></link>
<link rel="stylesheet" href="../../styles/vs.min.css">
<meta charset="utf-8">


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script src="/CustomScripts.js"></script> 
<!-- Pels blocks de codi -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<!-- scale font size for MathJax -->
<title>METODOLOGIA I TECNOLOGIA DE LA PROGRAMACIÓ</title>

</head>

<body>

<div id = "menu"></div>

<div id = "content">
  <center>
    <h1 class = "center">
      SEQÜÈNCIES I FITXERS
    </h1>
  </center>
    
<!-- Contingut escrit -->
<h4>Què és una seqüència</h4>
<teoria>
    Una seqüència és una successió finita d'elements (normalment) del mateix tipus, poguent ser naturals, enters, reals, caràcters o strings.
	<br>S'accedeix de manera seqüencial als seus elements. No es pot anar endavant ni endarrere ni tampoc anar indiscriminadament on es vulgui. 
	Aixó fa que calgui una marca de fi, per poder saber on acaben. Es poden associar a els canals d'entrada sortida estàndars (pantalla i teclat) o a un fitxer 
	i tenen permisos de lectura o escriptura, mai ambdós.

	<br><br>

    <h2>Exemples de sequencies</h2>
   
   <pre><code class = "c++">	
		// Seqüència d’enters (positius)
		2 34 23 34 76  12 4  6765 132 … 3 -1
   
		//Seqüència de reals (majors que 0)
		2.34 23 34.76  12.34  67.65 12 … 1.2 0

		//Seqüència de caràcters
		avui fa sol#

		//Seqüència de dates 
		2 3 2023 3 12 2017 … 4 6 1999 0

    </code></pre>
    Podem veure que la marca de fi sempre està present, sent -1 en la primera, 0 en la segona, un # en la tercera, i en la última un 0.
</teoria>
   
   <br><br>
   
   
    <h4>Marques de fi</h4>
<teoria> 
	Es poden donar dos tipus de marques de fi:
	<ul>
		<li><strong>Marca de fi lògica (explícita):</strong> Donada per un element distingit del mateix tipus que els de la seqüència, com ara els vists en l'exemple anterior.<br>
		Pot ser usada tant en les sequencies de teclat com les de fitxer.
		<br><br>
		<img class="allargatPetit" src="../../Recursos/Imatges/Sequencies_marquesFiLogiques.PNG" alt="exemple de marques de fi lògiques">
		<br><br>
		</li>
		<li><strong>Marca de fi física (implícita):</strong> Donada per la marca de final de fitxer del sistema. Com es pot intuir, doncs, només es pot usar en fitxers.
		<br><br>
		<img class="allargatPetit" src="../../Recursos/Imatges/Sequencies_marquesFiFisiques.PNG" alt="exemple de marques de fi físiques">
		<br><br>
		</li>
		
	</ul>
</teoria>
	
	
<h1>
    PROBLEMES DE SEQÜÈNCIES
</h1>
<teoria>
	Els problemes amb seqüències es resolen utilitzant els dos esquemes bàsics següents:
	<ul>
		<li> <strong>Recorregut:</strong> cal tractar tots els elements de la seqüència fins a arribar a la marca de fi. </li>
		<li> <strong>Cerca:</strong> si trobem el que cerquem, parem (no cal arribar a la marca de fi), sinó, arribem al final. </li>
	</ul>
	<alerta> Si el problema no exigeix un recorregut, es considera incorrecte aplicar-li. <br></alerta>
	
	<br><br>
	<h2>Recorregut</h2>
	<br><br>
	Esquema en pseudocodi:
		
	<br><br><pseudocodi>
	<pre><code class = "nohighlight">	
		inicialitzar tractament
		llegir element
		mentre no fi de la seqüència fer
			tractar element actual
			llegir element	
		tractament final
    </code></pre>
	</pseudocodi>
	
	En el recorregut cal veure que en el bucle, processem tots els elements de la seqüència, o sigui, fins a trobar la marca de fi.
	
	<br>L'esquema equivalent en c++ sería així:<br><br>
	<pre><code class = "c++">	
	...
	const tipus EOS=element_marca_fi; 
	...
	int main(){
	   ... 
	   inicialitzar_tractament(...);
	   cin>>element; //llegir el primer
	   //mentre no fi: not element==EOS
	   while(element != EOS) {
		  tractar_element(element,...);
		  cin>>element; //llegir el següent
	   }
	   tractament_final(...);
	   ...
	   return 0;
	}
    </code></pre>
	<br><br>
	<h2>Cerca</h2>
	<br><br>
	
	Esquema en pseudocodi:
		
	<br><br><pseudocodi>
	<pre><code class = "nohighlight">	
		inicialitzar tractament
		llegir element
		mentre no fi de la seqüència i no trobat fer
			tractar element actual
			llegir element	
		tractament final
    </code></pre>
	</pseudocodi>
	
	En la cerca cal veure que en el bucle, processem només els elements necessaris fins que detectem la marca de fi de la seqüència o es troba el que es busca.	
	
    <img class ="codeGif" src="../../Recursos/Gif/GifCerca_d.gif" alt="Gif del funcionament de l'esquema de cerca">
	
	<br>L'esquema equivalent en c++ sería així:<br><br>
	<pre><code class = "c++">	
	... 
	const tipus EOS=element_marca_fi;
	...
	int main() {
	   ...
	   inicialitzar_tractament(trobat,...); //trobat=false
	   cin>>element; //llegir el primer
	   //mentre no fi: not(element==EOS or trobat)
	   while(element != EOS and not trobat) {
		  tractar_element(element,trobat,...);
		  if(not trobat) 
			 cin>>element; //llegir el següent
	   }
	   tractament_final(trobat,...);
	   ...
	   return 0;
	}

    </code></pre>
	<br><br>
</teoria>    
 <br><br>

 
<h1>
    SEQÜÈNCIES EN C++: STREAMS
</h1>
<teoria>
	El C++ no disposa del concepte abstracte de seqüència, les seqüències s'implementen amb streams que permeten el flux (entrada i sortida) de dades:
	<br><br>
	<img class="mitjana" src="../../Recursos/Imatges/SequenciesFitxers_streams.PNG" alt="imatge explicativa sobre streams">
	<br><br>
	
	Per poder treballar amb streams, cal incluir les llibreries fstream o iostream. C++ utilitza diferents streams:
	<ul>
		<li>
			<strong>Streams d'entrada:</strong> 
			<ul>
			<li>istream: crea l'stream cin, connectat amb l'entrada per teclat.</li>
			<li>ifstream: permet l'entrada desde fitxer, havent de crear una variable ifstream i associar-la al fitxer d'on es vol llegir.</li>
			</ul>
		</li>
		<li>
			<strong>Streams de sortida:</strong> 
			<ul>
			<li>ostream: crea l'stream cout, connectat amb la sortida per pantalla.</li>
			<li>ofstream: permet la sortida a fitxer. Funciona igual que el ifstream.</li>
			</ul>
		</li>
		<li>
			<strong>Streams d'entrada/sortida:</strong> 
			<ul>
			<li>iostream: crea cin i cout com a variables globals i els conneta amb l'entrada per teclat i a sortida per pantalla, respectivament.</li>
			<li>fstream: permet llegir i escriure a fitxer, cal declarar variables i associar-les a un fitxer.</li>
			</ul>
		</li>
	</ul>
	

</teoria>
<h1>
SEQÜÈNCIES AMB FITXERS
</h1>
<teoria>

	Per poder treballar amb un fitxer cal incloure la llibreria fstream, declarar una variable stream del tipus corresponent i associar-la a un fitxer, obrint-lo o associant-lo al declarar-lo.
	En els següents exemples es pot veure les diferents maneres d'obrir un fitxer. 
	<pre><code class="c++"> 
	#include<fstream>
	...
	int main(){
		...
		ifstream f_entrada;
		f_entrada.open("dades.dat"); //pot tenir qualsevol extensió
		...								
		ofstream f_sortida;
		<strong>//El fitxer ha de estar en el mateix directori que el .cpp, si no hi és hem d'indicar el directori complet</strong>
		f_sortida.open("C:\\prova\\out.txt"); /*les rutes en Windows porten el
			símbol \, que en C++ es representa com a \\ (en UNIX s’usa /)*/
		...
		string nom_fitxer;
		cin>>nom_fitxer;   
		ifstream fitxer_in(nom_fitxer.c_str()); <strong>//cal usar .c_str() si tenim el nom en una variable.</strong>
		...
		fstream fitxer("dades.dat",fstream::in); //fstream de lectura. Al usar fstream cal activar lectura o escriptura (fstream::in o fstream::out)
		...
	}
	</code></pre>
</teoria>

<h1>
SEQÜÈNCIES D'ENTRADA I SEQÜÈNCIES DE SORTIDA 
</h1>
<teoria>
<h4>Seqüències d'entrada: lectura</h4>

Per llegir una seqüència es pot usar:
<ul>
	<li> <strong>L'operador d'extraccio >></strong> que llegeix amb format (d'acord amb el tipus de la variable). <br>
	Exemple: 
	<pre><code class="c++">
	ifstream fitxer("nom_fitxer.txt"); 
	unsigned n;      fitxer>>n;        //cin>>n;
	string paraula;  fitxer>>paraula;  //cin>>paraula;
	char lletra;     fitxer>>lletra;   //cin>>lletra;
	</code></pre>
	Pels tipus numèrics i les strings, >> llegeix fins a trobar-se un white-space (ws) i converteix el valor llegit al tipus de la variable. Els white-spaces (WS) són els caràcters no visibles del codi ASCII. El C++ els empra en la lectura amb format. El més habituals són: ' '(espai) '\r'(enter) '\n'(salt de línia) '\t'(tabulador).
	Si és un caràcter, llegeix només un caràcter, ometent els espais en blanc.
	</li>
	<li>
	<strong>Lectura de caràcters:</strong>
		<ul>
			<li> .get() llegeix caràcters sense ometre ws. Aquest efecte també es pot aconseguir amb >> usant l'opció <strong>noskipws</strong>
			<pre> <code class="c++"> 
			char lletra = fitxer.get(); //lletra=cin.get();
			fitxer.get(lletra);         //cin.get(lletra);</code></pre> 
			</li>
			<li> .unget torna a fer accessible (només) el darrer caràcter llegit.
			</li>
		</ul>
	</li>
</ul>

<h2> Marca de fi </h2><br><br>

Cal tenir en compte que ha de ser detectada al ser llegida, <alerta>és un error continuar llegint!</alerta>
A més, també és recomenable que, si n'hi ha, la marqua de fi lògica vagi seguida d'un WS, per evitar problemes en la detecció.
<br>
El fi de seqüència física, en C++, es detecta amb la funció .eof() que retorna un booleà que dona cert si s'ha arribat a la marca de fi.
Pel cas de una marca de fi lògica, podem definir una constant EOS, donant-li el valor que volem que tingui la marca de fi, llavors per detectar-la, és una simple comparació d'igualtat (==).


<h4>Seqüències de sortida: escriptura</h4>

Per escriure en una seqüència d'entrada es pot usar:
<ul>
	<li>
		<strong> L'operador d'inserció << </strong> que ens permet escriure elements de tipus conegut. 
		<pre><code class="c++">
ofstream fitxer; 
fitxer.open("arxiu.txt");
//Escriptura amb format
char caracter='a';
unsigned n=15; 
cout<<caracter<<" enter: "<<n<<endl; 
fitxer<<caracter<<" enter: "<<n<<endl;
		</code></pre>
		<br> Aquest codi ens escriuria en el fitxer i en pantalla el següent: <br>
		<img class="allargatPetit" src="../../Recursos/Imatges/SequenciesFitxers_escriptura.PNG" alt="resultat del codi anterior"/>
		Com veiem, escriu tant el caracter com el enter en el format corresponent. El \r\n correspondria al salt de línia en Windows. 
		
	</li>
	<li>
		<strong> .put()</strong> que permet escriure caràcters (d'un en un). 
		<pre> <code class="c++">
//Escriptura d’un caràcter
char caracter='.';
fitxer.put(caracter); //Escriu el caràcter
cout.put(caracter); //Escrivim el caràcter a la pantalla

		</code> </pre>
		<br> Afegint aquest codi al anterior, ens resultaria en el següent:<br><br>
		<img class="allargatPetit" src="../../Recursos/Imatges/SequenciesFitxers_escriptura2.PNG" alt="resultat del codi anterior"/>
		<br>Com veiem s'afageix el punt després del salt de línia, on hi havia el cursor.
	</li> 
</ul>

<h2> Marca de fi </h2><br><br>

La marca de fi física la posa el sistema en el moment de tancar el fitxer. La lógica, si és necessària, cal escriure-la, seguida d'un WS, abans de tencar el fitxer.

</teoria>



  <p class = footer>
  <center>
      <p class = footer>
      <!--<em>Last modified on February 19, 2018.</em><br><br>-->
      Copyright &copy; 2000&ndash;2018
      <a href ="https://www.udg.edu/ca/" class = footer>Universitat de Girona</a>
      Tots els drets reservats.
  </center>
</div>



</body>

</html>

