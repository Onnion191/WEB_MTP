<!DOCTYPE html>

<html lang="ca">

<head>


<link rel="stylesheet"  href="../../styles/Style.css" type="text/css" media="screen">
<link rel="stylesheet" href="../../styles/vs.min.css">
<meta charset="utf-8">


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script src="../../CustomScripts.js"></script> 
    <!-- Pels blocks de codi -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<!-- scale font size for MathJax -->
<title>METODOLOGIA I TECNOLOGIA DE LA PROGRAMACIÓ</title>

</head>

<body>

<div id = "menu"></div>

<div id = "content">
  <center>
    <h1 class = "center">
      ESTRUCTURES ALTERNATIVES
    </h1>
  </center>
    
<!-- Contingut escrit -->
<h4>Presa de decisions</h4>
<teoria>
     Sovint el programador necessita saber en quin estat es troba el programa, (valor de variables, iteracions que ha fet dins d'un bucle, comprovar dades d'entrada de l'usuari...), i actuar en conseqüència. Això comporta que ens podem trobar en diferents valors de variables i potser no hem de tractar-les de la mateixa manera. <h2>Per exemple: què passa si demanem a l'usuari que entri una lletra i ens entra un nombre?</h2> <br>
    Així doncs, sovint és valora quin és l'estat de les variables i es prèn una decisió.
    <br><br>
    
</teoria>
   
<h1>
   BOOLEANS
</h1>
<teoria>
    Com hem vist anteriorment en els <a href="../TipusVariables/TipusVariables_Teoria.html" >tipus de variables</a> sabem que existeix un tipus lògic o booleà, que ens permet guardar estats com cert o fals. Aquestes variables seràn les que utilitzarem per prendre decisions. Efectuarem una comprovació i si el resultat és cert farem un seguit de coses, i si és fals unes altres.<br><br>
    <h2>Implementació en c++</h2>
    <br><br>
    Exemple senzil:
        <pre><code class="c++">
        #include &lt;iostream&gt;
        using namespace std;
        //Entrada: llegeix un nombre enter de l'usuari. 
        //Sortida: Si cal, converteix l'enter en positiu, i el mostra per pantalla. 
        int main(){
            int a = 0; cout&lt;&lt;"Entra un nombre: ";//Demanem al usuari que entri un nombre qualsevol
            cin&gt;&gt;a;
            bool negatiu = a &lt; 0;
            if (negatiu){//Si es negatiu ( a mes petit que 0) --> la expressió valdra cert i entrarà dins del "if"
            
                a*=-1;//Passem el nombre a positiu
                cout&lt;&lt;"El teu nombre amb valor positiu es: " &lt;&lt; a &lt;&lt; endl;
            }
            else {//Si es positiu (a NO més petit que 0)--> la expressió valdra fals i entrarà dins del else 
                cout &lt;&lt; "El teu nombre ja es positiu" &lt;&lt; endl;
            }
            return 0;

        }
        </code></pre>
    En aquest exemple simple hem vist com evaluar l'estat d'una variable " a " i actuar d'una manera o una altre.
    </teoria>    
 <br><br>
    
<h1>Cadena de condicionals:</h1>   
    <br><br>
<teoria>
    En l'exemple anterior hem vist com fer una estructura alternativa, però molts cops necessitem fer múltiples comprovacions o bé evaluar diferents variables per determinar si una cosa és certa o és falsa. <br>
    Per exemple, si volem saber si hem d'anar a recuperació d'una assignatura, hem de comprovar que la nostra mitjana sigui superior o igual a 5. I al mateix temps haver tret la nota mínima en l'examen. En aquest cas es plantejen dues condicions per saber si hem d'anar a recuperar o no. <br>
    Per resoldre aquests problemes ho podem fer principalment de dues formes: 
    <ul>
        <li> Utilitzant operadors condicionals vists a en la seccio de <a href="../TipusVariables/TipusVariables_Teoria.html" >tipus de variables</a>.</li>
        <li>Utilitzant estructures encadenades de condicionals</li>
    </ul>
    <br>
    <h4> Operadors de condicionals</h4>
    <br> 
    En aquest cas utilitzarem els operadors condicionals que tenen un ús molt semblant a una porta lògica.<br> 
    Calcularem i guardarem en una variable booleana si hem aprovat l'examen final <h2>i</h2> si tenim una mitjana igual o superior a 5. <br><br>
    <h2>Implementació en c++</h2>
    <pre><code class="c++">
      
            if(nota >= minExamen && mitjana >=5)//Si té l'examen aprovat i la mitjana aprovada
            {
                cout&lt;&lt;"Felicitats has aprovat"&lt;&lt;endl;
            }
            else 
            {
                cout&lt;&lt;"La mitjana o l'examen no arriben a la nota minima. "&lt;&lt;endl;
            }
    </code></pre>
    En l'exemple anterior hem utilitzat els operadors " and "  i " or " per tal de determinar si una condició era certa o falsa. Aquesta metodologia té els seus avantatges i inconvenients: <br>
    <h2>Avantatges: </h2>
    <br>
    <ul>
        <li>Codi molt més net</li>
        <li>Fàcil d'entendre per qualsevol persona</li>
        <li>Fàcil de debugar</li>
    </ul>
    <h2>Inconvenients: </h2><br>
    <ul>
        <li>No es pot saber quina condició ha fallat: En el nostre exemple no podem saber si l'usuari suspèn per culpa de l'examen o de la mitjana</li>
        <li>Si hi ha molts operadors dins d'una mateixa condició es torna illegible</li>
    </ul>
</teoria>
  <br><br>
    <h4>Estructures Encadenades</h4>
    <br>
<teoria>
    A diferència del cas anterior, utilitzarem condicions unitàries però encadenades entre elles per aconseguir tenir condicions compostes. Aquesta pràctica no és la més recomenable per la seva càrrega directe al codi, però ens permet saber en tot moment què és el que està passant. 
    <br>
    <h2>Implementació en c++</h2>
    
        <pre><code class="c++">

            if(nota >= minExamen)//Si té l'examen aprovat
            {
                if(mitjana >= 5)//Si té la mitjana aprovada
                {
                    cout&lt;&lt;"Felicitats has aprovat"&lt;&lt;endl;
                }
                else//Si té la mitjana suspesa
                {
                    cout&lt;&lt;"La mitjana no t'arriba al 5"&lt;&lt;endl;
                }
            }
            else //Té l'examen suspès
            {
                cout&lt;&lt;"l'examen no arriba a la nota minima. "&lt;&lt;endl;
            }

        }
    </code></pre>
    Ara que hem vist com es fan les estructures encadenades podem veure quins avantatges i inconvenients té:<br>
    <h2>Avantatges:</h2>
    <br>
    <ul>
        <li>Permet conèixer en tot moment l'estat de les condicions i saber què és el que falla.</li>
    </ul>
    <br>
    <h2>Inconvenients:</h2>
    <br>
    <ul>
        <li>Carrega visual del codi</li>
        <li>Es dificil de seguir per qualsevol altre persona</li>
        <li>S'ha de controlar moltes branques, i és fàcil generar forats de codi o errors</li>
        <li>Augment del tamany considerable del codi</li>
  </ul>
  <br>
  
</teoria>
    <h1>CONSELLS</h1>
    <br>
<teoria>
    Com hem vist, tenim diferents maneres de tractar amb les estructures alternatives, però si no es tracten bé poden ser una font de problemes. Per tal d'evitar que ens pugui passar, hi ha les següents directrius que poden ajudar a orientar el programador: <br>
    <ul>
        <li><h2>Utilitzar Operadors condicionals:</h2> sempre que es pugui, d'aquesta manera mantenim net el codi i ens permet descobrir errors amb molta més facilitat.</li>
        <li><h2>No més de 3 condicions:</h2> Si necessitem fer una composició de més de 3 operadors, aleshores és que possiblement ens estem equivocant en alguna cosa. El més normal sol ser 1 operador o 2.</li>
        <li><h2>Deixar les branques buides:</h2> Com hem vist abans, a vegades no volem implementar res quan no es compleix una condició, una bona pràctica és deixar la branca escrita i amb un comentari anotar que no es fa res. D'aquesta manera un dóna constància que ha tingut en comtpe aquella possibiltiat i que ha preferit no fer res.</li>
    </ul>
</teoria>
    
  <p class = footer>
  <center>
      <p class = footer>
      <!--<em>Last modified on February 19, 2018.</em><br><br>-->
      Copyright &copy; 2000&ndash;2018
      <a href ="https://www.udg.edu/ca/" class = footer>Universitat de Girona</a>
      Tots els drets reservats.
  </center>
</div>



</body>

</html>

