<!DOCTYPE html>

<html lang="en">

<head>


<link rel="stylesheet"  href="../../styles/Style.css" type="text/css" media="screen"></link>
<link rel="stylesheet" href="../../styles/vs.min.css">
<meta charset="utf-8">


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script> 
<script src="/CustomScripts.js"></script> 
<!-- Pels blocks de codi -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<!-- scale font size for MathJax -->
<title>METODOLOGIA I TECNOLOGIA DE LA PROGRAMACIÓ</title>

</head>

<body>

<div id = "menu"></div>

<div id = "content">
  <center>
    <h1 class = "center">
      BUCLES I ITERACIONS
    </h1>
  </center>
    
<!-- Contingut escrit -->
<h4>Què és un bucle</h4>
<teoria>
    Anomanem bucle aquella estructura que repeteix una sèrie d'instruccions de forma consecutiva fins que es deixa de complir una condició. Aquestes condicions són els encarregats de controlar el flux de l'estructura i decidir quan se'n surt. Així doncs, és important establir condicions vàlides per evitar resultats indesitjats, o bé, que el programa es quedi atrapat dins del bucle. 
    A continuació explicarem algunes estructures iteratives:
    <br><br>
    
</teoria>
   
<h1>
   Mentre
</h1>
<teoria>
    Entenem un "mentre" una estructura iterativa que MENTRE es compleix una condició va iterant sobre ella mateixa. En el moment que la condició no es compleix, aleshores es trenca el bucle i segueix executant el programa amb normalitat. Un cop la condició és falsa, <alerta> no es torna a executar el codi del bucle!</alerta>. Un exemple seria escriure nombres del 0 al 9 en format bucle. Mentre el nombre que ha d'escriure sigui menor que 9, escriure per pantalla i incrementar el nombre.<br>
    <pseudocodi>
        <pre><code class="nohighlight">
            mentre n menor 9
                escriurePantalla
                incrementar n
            fi mentre
        </code></pre>
    </pseudocodi>
    <h2>Repassem la execució d'aquest tall de codi:</h2> <br><br>
    Per tal d'agilitzar l'execució, en comptes de fer fins a 9, hem il·lustrat fins a 2. El mecanisme és el mateix:
    <ul>
    <li>Primer evaluem la condició si es compleix.</li>
        <li>Si es compleix, s'executen les instruccions de dins el mentre.</li>
        <li>Si no es compleix, s'abandona el mentre.</li>
    </ul>
    <img class ="codeGif" src="../../Recursos/Gif/MentreTrasa.gif" alt="Gif del funcionament del mentre">
    <br><br>
    <h2>Implementació en c++</h2>
    <br>
    <pre><code class="c++">
            int n = 0;
        while(n &lt; 9)
        {
            cout&lt;&lt;"El valor de n es: "&lt;&lt;n&lt;&lt;endl;
            n++;
        }
        cout&lt;&lt;"El valor de n es major de 9"&lt;&lt;endl;
    </code></pre>

</teoria>    
 <br><br>
    
<h1>Per:</h1>   
    <br><br>
<teoria>
   El " per " és una altre esctructura iterativa amb un nombre d'iteracions fixat, on una variable de control va modificant el seu valor fins a incumplir una condició, quan això passa es trenca el bucle. D'aquests paràmetres se'n diuen inicialitzacio, finalització i pas:
    <ul>
        <li><h2>Inicialitzacio:</h2> Quin es el valor inicial de la variable de control (n en el cas anterior).</li>
        <li><h2>Finalització:</h2> Quina condició ha de complir. (n &lt; 9, en el cas anterior)</li>
        <li><h2>El pas:</h2> Com es modificarà la variable de control en cada iteració.( n++ en el cas anterior)</li>
    </ul>
    <br>
    En pseudocodi utilitzem la seguent expressio: 
        <pseudocodi>
        <pre><code class="nohighlight">
            per var_control de valor_inicial fins valor_final pas +1 fer 
                FerQuelcom();
            fi per 
        </code></pre>
    </pseudocodi>
    
    <img class="codeGif" src="../../Recursos/Gif/BuclePer.gif" alt="Gif mostrant com funciona el per" >
    
    Aquest codi el que fa és, la var_control s'inicialitza al valor_inicial. I fins que no hagi arribat al valor_final, augmenta el seu valor en 1. D'aquesta manera va iterant i executant les <a href="../AccionsFuncions/AccionsFuncions_Teoria.html">funcions i accions </a>que es trobin dins de l'estructura. 
    <br>
    
    <h2>Informació adicional:</h2>
    <ul>
        <li>El pas pot ser qualsevol valor, tant positiu com negatiu.</li>
        <li>La variable de control no s'hauria de modificar dins del per, pot donar lloc a resultats indesitjats.</li>
        <li>En la major part dels casos, la variable de control deixa d'existir un cop hem sortit del per.</li>
        <li>En pseudocodi, entenem el per, com una varible que va de valor A a valor B. En c++, hi ha més possibilitats
            <ul>
                <li>Anar de A B, igual que l'exemple amb pseudocodi.</li>
                <li>Anar de A fins a "desconegut" mentre es compleixi una condició, per exemple: A sigui diferent de C.</li>
            </ul>
        </li>
    </ul>
    
    <h2>Implementació en c++</h2><br>
    Exemple: bucle "per" que fa 9 iteracions:<br>
    <pre><code class="c++">
    for(unsigned int x = 0; x &lt; 9; x++)
    {
        cout&lt;&lt;"El valor de x es: "&lt;&lt;x&lt;&lt;endl; 
    }    
    </code></pre>
        Exemple: bucle "per" que itera sempre que es compleixi una iteracio: <br>
    <pre><code class="c++">
    #include &lt;cstdlib&gt;
    
    srand(5);
    int i = rand()%100; 
    for(unsigned int y = 0; y != i; y = (y+1)%100)
    {
        cout&lt;&lt;"No he encertat el nombre :" &lt;&lt;y&lt;&lt;" es diferent de "&lt;&lt;i&lt;&lt;endl;
        i = rand()%100;
    }
    </code></pre>
    
    En aquest exemple, la variable y augmentant de forma cíclica (entre 0 i 99), fins que el valor de y sigui igual a i. Mentre que " i ", va canviant el seu valor per un aleatori comprès entre 0 i 99. 
    En aquest cas, el nombre de iteracions que farà és indefinit. <br>
    <alerta>Nota: sempre que usem un for, és perquè estem segurs que acabarà, ja que no tenim forma d'aturar-lo en cas de que tardi massa.</alerta>
    </teoria>
    
    
  <p class = footer>
  <center>
      <p class = footer>
      <!--<em>Last modified on February 19, 2018.</em><br><br>-->
      Copyright &copy; 2000&ndash;2018
      <a href ="https://www.udg.edu/ca/" class = footer>Universitat de Girona</a>
      Tots els drets reservats.
  </center>
</div>



</body>

</html>

