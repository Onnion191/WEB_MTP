<!DOCTYPE html>

<html lang="ca">

<head>


<link rel="stylesheet"  href="../../styles/Style.css" type="text/css" media="screen"></link>
<link rel="stylesheet" href="../../styles/vs.min.css">
<meta charset="utf-8">


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script src="../../CustomScripts.js"></script> 
    <!-- Pels blocks de codi -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

    <!-- scale font size for MathJax -->
    <title>UDG AJUTS DE PROGRAMACIÓ</title>

</head>

<body onload="checkMenuById('#collapse-input-0');">

<div id = "menu"></div>

<div id = "content">
  <center>
    <h1 class = "center">
    8.1 CONCEPTE I DISSENY RECURSIU
    </h1>
  </center>

  <h3>CONCEPTE</h3>
  <teoria>
  Una acció o funció recursiva és aquella que es crida a ella mateixa. 
  
  <ul>
    <li>Hi ha equivalència amb la iteració. </li>
    <li>Es genera una seqüència o arbre de crides: el nombr ede crides és finit i cada crida té el seu propi espai de variables i paràmetres a la memòria.</li>
    <li><b>Avantatges: </b> en general els algorismes recursius són més senzills (i elegants) que les seves versions iteratives i resulten més fàcils de verificar.</li>
    <li><b>Eficiència: </b> el cost asimptòtic en temps és el mateix que el de la corresponent versió iterativa (però, amb un petit increment de temps). El cost en espai de memòria augmenta i, en ocasions, pot ser crític.</li>
  </ul>
  
  
  </teoria>

  <h3>DISSENY RECURSIU</h3>

  <teoria>
  <h4>Classificació</h4>
  Podem classificar segons el nombre de crides generades, la recursivitat pot ser 
  <ul>
    <li><b>simple:</b> cada crida genera com a molt una altre crida</li>
    <li><b>múltiple:</b> cada crida pot generar vàries crides</li>
  </ul>

  També podem classificar segons el que fa després de la crida. Un algorisme recursiu simple pot ser
  <ul>
    <li><b>final:</b> la crida recursiva és el últim que fa</li>
    <li><b>no final:</b> hi ha operacions posteriors a la crida recursiva</li>
  </ul>

  Hi ha altres formes de classificació:

  <ul>
    <li>Esquema pur: no fa servir la iteració</li>
    <li>Esquema mixt: combina recursivitat i iteració</li>
    <li>Recursivitat indirecta: quan una funció A crida una funció B i B crida A.</li>
  </ul>

  <h4>Exemples</h4>

  <h2>Factorial<br></h2>

  <teoria>
    Definició del factorial: <codi>n! = n&bull;(n-1)&bull;(n-2)&bull;...&bull;2&bull;1</codi> 
    <br>
    Definició recursiva del factorial: <codi>n! = n&bull;(n-1)!</codi>, per <codi>n>0</codi> i <codi>0!=1</codi> <br><br>

    <h2>Solució Iterativa</h2>
    
    <button onclick="myFunction(P8_1_1)">Veure Codi</button><br>
		<solucio id="P8_1_1">
      <pre><code class = "c++">unsigned factorial(unsigned n) {
// Pre: cert
// Post: retorna n!
    unsigned f = 1;
    for(unsigned i = 1; i &lt;= n; i++) f = f*i;
    return f;
}</code></pre></solucio>

  <h2>Solucions Recursives:</h2>
  <ul>
    <li>Simple final 1 <button onclick="myFunction(P8_1_2)">Veure Codi</button><br> </li>
    <li>Simple final 2 <button onclick="myFunction(P8_1_3)">Veure Codi</button><br> </li>
    <li>Simple no final <button onclick="myFunction(P8_1_4)">Veure Codi</button><br> </li>
  </ul>

  <solucio id="P8_1_2">
    <pre><code class = "c++">unsigned factorial(unsigned n) {
// Pre: cert
// Post: retorna n!
    unsigned f;
    if(n == 0) f = 1;  //branca directa
    else f = n * factorial(n-1); //branca recursiva
    return f;
}</code></pre></solucio>

<solucio id="P8_1_3">
    <pre><code class = "c++">unsigned factorial(unsigned n) {
// Pre: cert
// Post: retorna n!
    if(n == 0) return 1;
    else return  n * factorial(n-1);
}</code></pre></solucio>

<solucio id="P8_1_4">
    <pre><code class = "c++">unsigned factorial(unsigned n) {
// Pre: cert
// Post: retorna n!
    unsigned f;
    if(n == 0) f = 1;
    else {
        f = factorial(n-1); 
        f = f * n;    
    }
    return f;
}</code></pre></solucio>

  </teoria>

  <h2>Fibonacci:</h2><br>
  <teoria>
    Sèrie de Fibonacci <codi>0,1,1,2,3,5,8,13,21,34,55..</codi> <br>
    Definició recursiva: <codi>fib(n): fib(n-1) + fib(n-2)</codi> per <codi>n>=2</codi>; <codi>fib(n) = n</codi> per <codi>n==1 || n==2</codi>
    <br><br>
    <b>Solució </b>
    <button onclick="myFunction(P8_1_5)">Veure Codi</button><br>
		<solucio id="P8_1_5">
        <pre><code class = "c++">unsigned fibonacci(unsigned n) {
// Pre: cert
// Post: retorna fibonacci(n)
    int fib;
    if(n &lt; 2) fib = n;
    else fib = fibonacci(n-1) + fibonacci(n-2);
    return fib;
}</code></pre>

    Cal veure que aquesta solució es ineficient posat que calculem la seqüència per els dos valors en el <codi>else</codi>. <a href = "Recursivitat_Immersiu.html">En l'apartat de disseny immersiu, es veu una solució més eficient.</a>
    </solucio>
    </teoria><br>
  
  <h2>Potència:</h2>  <button onclick="myFunction(P8_1_6)">Veure Codi Solució 1</button> <button onclick="myFunction(P8_1_7)">Veure Codi Solució 2</button><br><br>
  <solucio id="P8_1_6"><pre><code class = "c++">unsigned potencia(unsigned base, unsigned exponent) {
// Pre: base&gt;0 
// Post: retorna base^exponent
    unsigned resultat;
    if(exponent== 0) resultat= 1;
    else resultat = base * potencia(base,exponent-1);
    return resultat;
}</code></pre></solucio>

<solucio id="P8_1_7"><pre><code class = "c++">double potencia(int base, int exponent) {
// Pre: base&lt;&gt;0
// Post: retorna base^exponent
    double resultat;
    if (exponent == 0) resultat = 1.0;
    else {
        if(exponent&gt;0) resultat = base * potencia(base,exponent-1);
        else resultat= 1.0/base*potencia(base,exponent+1);
    }
    return resultat;
}</code></pre></solucio>


<h2>Suma dígits:</h2>   <button onclick="myFunction(P8_1_8)">Veure Codi</button> <br>

<solucio id="P8_1_8"><pre><code class = "c++">unsigned suma_digits(unsigned n){
// Pre: cert
// Post: retorna la suma dels d&iacute;gits de n 
    unsigned resultat;
    if (n &lt; 10) resultat = n;
    else resultat = n%10 + suma_digits(n/10);
    return resultat;
}</code></pre></solucio> <br>

<h2>Mostrar capgirat d'un nombre: </h2>   <button onclick="myFunction(P8_1_9)">Veure Codi</button> <br>

<solucio id="P8_1_9"><pre><code class = "c++">void mostra_capgirat(unsigned n){
// Pre: cert 
// Post: escriu el capgirat de n
    if(n &lt; 10) cout&lt;&lt; n;
    else{
        cout &lt;&lt; n%10;
        mostra_capgirat(n/10);
    }
} </code></pre></solucio><br>

<h2>Màxim comú divisor amb l'algorisme d'Euclides: </h2>   <button onclick="myFunction(P8_1_10)">Veure Codi</button> <br>

<solucio id="P8_1_10"><pre><code class = "c++">unsigned mcd(unsigned a, unsigned b){
// Pre: a&gt;0 i b&gt;0
// Post: retorna m.c.d.(a,b)
    if (a%b== 0) return b;
    else return mcd(b,a%b);
} </code></pre></solucio><br>


<h2>Arrel digital: </h2>   <button onclick="myFunction(P8_1_11)">Veure Codi</button> <br>

<solucio id="P8_1_11"><pre><code class = "c++"> unsigned arrel_digital(unsigned n) {
// Pre: cert 
// Post: retorna l'arrel digital de n
    if(n &lt; 10 )return n;
    else return arrel_digital(suma_digits(n));
}</code></pre></solucio><br>


  <h2>Canvi de Base: </h2>   <button onclick="myFunction(P8_1_12)">Veure Codi</button> <br>

  <solucio id="P8_1_12"><pre><code class = "c++">unsigned canvi_base(unsigned n, unsigned b){
// Pre: b&gt;=2 i b&lt;=9
// Post: retorna n en base b 
    unsigned resultat;
    if(n &lt; b) resultat = n;
    else resultat= canvi_base(n/b,b)*10 + n%b;
    return resultat;
}</code></pre></solucio><br>
  
<h2>Torres de Hanoi: </h2>   <button onclick="myFunction(P8_1_13)">Veure Codi</button> <br>

<solucio id="P8_1_13"><pre><code class = "c++">void hanoi(unsigned n, char from, char to, char aux){
// Pre: cert[n &eacute;s el nombre de discos i from, to i aux s&oacute;n els s&iacute;mbols de les piles]
// Post: escriu els moviments de n discos de from a to usant aux 
    if(n &gt; 0){
        hanoi(n-1,from,aux,to);
        cout &lt;&lt; n &lt;&lt; &quot; &quot;&lt;&lt; from &lt;&lt; &quot;-&gt;&quot; &lt;&lt; to &lt;&lt; endl;
        hanoi(n-1,aux,to,from);
    }
}</code></pre></solucio><br>  

<h2>Cerca en un vector: </h2>   <button onclick="myFunction(P8_1_14)">Veure Codi</button> <br>

<solucio id="P8_1_14"><pre><code class = "c++">bool existeix(const Vector_enter a, unsigned n, unsigned x) {
//Pre: 0&lt;n&lt;=MAX
//Post: retorna cert si x existeix a a[0..n-1], altrament fals
    bool trobat;
    if(n==1) trobat = a[0]==x;
    else if(a[n-1]==x) trobat = true;
    else trobat = existeix(a,n-1,x);
    return trobat;
}</code></pre></solucio><br>
  
</teoria>
  

  
</div>
  <p class = footer>
  
  <a class="forward round" href="Recursivitat_Induccio.html"></a>
  <center>
      <p class = footer>
      Copyright &copy; 2000&ndash;<span id="anyActual"></span>
      <a href ="https://www.udg.edu/ca/" class = footer>Universitat de Girona</a>
      Tots els drets reservats.
  </center>



</body>

</html>

